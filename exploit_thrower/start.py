#!/usr/bin/env python2

from pwn import *
from swpag_client import Team
import requests
import json
import re
import time
import os
from multiprocessing.dummy import Pool as ThreadPool
import importlib

# Logging configuration
class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

original_info = log.info
log.info = lambda x: original_info(bcolors.OKBLUE + x + bcolors.ENDC)
log.header = lambda x: original_info(bcolors.HEADER + x + bcolors.ENDC)

original_success = log.success
log.success = lambda x: original_success(bcolors.OKGREEN + x + bcolors.ENDC)

original_failure = log.failure
log.failure = lambda x: original_failure(bcolors.FAIL + x + bcolors.ENDC)
log.fail_once = lambda x, errors_in_round: x in errors_in_round or log.failure(x)

# Team information
X_TEAM_TOKEN    = "INSERT_TEAM_TOKEN"

# Submission server URL
SUBMISSION_URL = "http://api.ictf2019.net/"

# Message types
NO_SUCH_FLAG        = "incorrect"
OWN_FLAG            = "ownflag"
ALREADY_SUBMITTED   = "alreadysubmitted"
ACCEPTED            = "correct"
TOO_MANY_INCORRECT  = "toomanyincorrect"
NOT_ACTIVE          = "notactive"

# Delays and timeouts
REQUEST_TIMEOUT     = 5 # HTTP Request timeouts (in seconds)
RECONNECT_DELAY     = 3 # Delay before attempting a new connection (in seconds)
ROUND_DELAY         = 30 # Seconds between each round

# Miscellaneous
EXPLOIT_FOLDER      = "exploits"

# iCTF API
team = Team(SUBMISSION_URL, X_TEAM_TOKEN)

def is_valid_flag(flag):
    """
    Checks if a string matches the flag format
    """
    return flag.startswith("FLG")

def remove_invalid_flags(flags):
    """
    Takes a list of flags and removes flags with an invalid format
    Returns a list of valid flags (format-wise)
    """

    # Validate flag format
    filtered_flags = [flag for flag in flags if is_valid_flag(flag)]

    number_of_removed_flags = len(flags) - len(filtered_flags)

    if number_of_removed_flags:
        log.failure("Removed {} flags with incorrect format.".format(number_of_removed_flags))

    return filtered_flags

def print_statistics_from_flag_responses(flag_responses, flags_per_handler):

    stats = {}

    for handler in flags_per_handler.keys():
        stats[handler] = {
            "number_of_invalid_flags" : 0,
            "number_of_own_flags" : 0,
            "number_of_already_submitted_flags" : 0,
            "number_of_accepted_flags" : 0,
            "total_points" : 0
        }

    for response in flag_responses:

        current_handler = None

        # Find which handler submitted a given flag
        for handler in flags_per_handler.keys():

            if response['flag'] in flags_per_handler[handler]:
                current_handler = handler

        if not current_handler:
            log.failure("Server responded with a flag that we have never submitted : {}".format(
                response['flag']))
            continue

        if response['message_type'] == NO_SUCH_FLAG:
            stats[current_handler]['number_of_invalid_flags'] += 1

        elif response['message_type'] == OWN_FLAG:
            stats[current_handler]['number_of_own_flags'] += 1

        elif response['message_type'] == ALREADY_SUBMITTED:
            stats[current_handler]['number_of_already_submitted_flags'] += 1

        elif response['message_type'] == ACCEPTED:
            stats[current_handler]['number_of_accepted_flags'] += 1
            stats[current_handler]['total_points'] += response['points']

        else:
            log.failure("Invalid message received : '{}'".format(response['message_type']))

    log.header("==== ROUND STATISTICS ===")
    for handler in stats.keys():
        number_of_invalid_flags = stats[handler]['number_of_invalid_flags']
        number_of_own_flags = stats[handler]['number_of_own_flags']
        number_of_already_submitted_flags = stats[handler]['number_of_already_submitted_flags']
        number_of_accepted_flags = stats[handler]['number_of_accepted_flags']
        total_points = stats[handler]['total_points']

        log.header("{:30} | {:7} | {:3} | {:17} | {:8} | {:20} |".format("Handler name",
            "Invalid", "Own", "Already submitted", "Accepted", "Points"))

        log.header("{:30} | {:7} | {:3} | {:17} | {:8} | {:20} |".format(handler,
            number_of_invalid_flags, number_of_own_flags, number_of_already_submitted_flags,
            number_of_accepted_flags, total_points))

def parse_response(flag_response):
    """
    Parses each individual flag response returned from submit_flags()
    Returns a dictionary containing { flag, is_valid, message_type, points }
    """

    points   = 0
    is_valid = False

    if NO_SUCH_FLAG in flag_response:
        message_type = NO_SUCH_FLAG

    if OWN_FLAG in flag_response:
        message_type = OWN_FLAG

    if ALREADY_SUBMITTED in flag_response:
        message_type = ALREADY_SUBMITTED

    if TOO_MANY_INCORRECT in flag_response:
        message_type = TOO_MANY_INCORRECT

    if NOT_ACTIVE in flag_response:
        message_type = NOT_ACTIVE

    if ACCEPTED in flag_response:
        message_type = ACCEPTED
        is_valid = True
        points = 1

    return {
        "flag" : "N/A",
        "is_valid" : is_valid,
        "message_type" : message_type,
        "points" : points
    }

def submit_flags(flags = []):
    """
    Submit flags to the submission server and parses the responses.
    Returns the parsed flag responses.
    """

    log.success("Submitting {} flags.".format(len(flags)))

    response = None

    # Loop until we receive a response from the submission server
    while not response:
        try:
            response = team.submit_flag(flags)

        except requests.ConnectionError as e:
            log.failure("Submission server is not up. Re-trying in {} seconds".format(
                RECONNECT_DELAY))
            time.sleep(RECONNECT_DELAY)

        except requests.ReadTimeout as e:
            log.failure("Submission server did not respond in {} seconds. Re-trying.".format(
                REQUEST_TIMEOUT))

        except Exception as e:
            log.failure("An unknown error occured when submitting the flags : {}".format(e))

    json_response = json.loads(response.text)
    flag_responses = [parse_response(response) for response in json_response]

    return flag_responses

def register_handlers(path = EXPLOIT_FOLDER):
    """
    Register exploit handlers from the exploit folder
    Returns the list of registered handlers
    """

    exploit_folder = './{}/{}'.format(os.path.dirname(__file__), path)
    handlers = []

    for module in os.listdir(exploit_folder):

        if not module.endswith(".py") or module == "__init__.py":
            continue

        # Execute the script
        # We assume that each executed script registers himself to the handlers dictionary.
        try:
            execfile('./{}/{}'.format(path, module))
        except Exception as e:
            log.failure("Could not register handler '{}' : {}".format(module, e))

    log.info("Registered {} handler(s).".format(len(handlers)))
    for handler in handlers:

        handler_name = handler.__name__
        log.info("- Registered '{}' handler".format(handler_name))

    return handlers

def get_opponent_ips():
    """
    Fetch the IPs of opponent teams.
    """
    global team

    while True:

        try:
            service_list = team.get_service_list()

            if service_list:
                service = service_list[0]
                targets = team.get_targets(service['service_id'])
                return [target['hostname'] for target in targets]
            else:
                return []
        except:
            log.info("Could not fetch oppponent list. Retrying in {} seconds...".format(
                RECONNECT_DELAY))
            time.sleep(RECONNECT_DELAY)

if __name__ == '__main__':

    log.info("Starting exploit throwing framework...")


    # Main round loop
    while True:

        log.header("==== ROUND START ====")

        # Register handlers
        handlers = register_handlers()

        # Dictionary containing a list of flags for each handler
        flags_per_handler = {}

        # Keep track of errors for this round
        errors = set()

        def exploit(opponent_ip):

            flags = []

            # Run each exploit
            for handler in handlers:
                handler_name = handler.__name__

                try:
                    flag = handler.get_flag(opponent_ip)
                    if flag != None:
                        flags.append((handler_name, flag.strip()))

                    handler.post_exploit(opponent_ip)

                except Exception as e:
                    error_message = "Service '{}' failed to get flag(s) : {}".format(
                            handler_name, e)

                    log.fail_once(error_message, errors)
                    errors.add(error_message)

            return flags

        # Iterate over each opponent
        pool = ThreadPool(100)
        results = pool.map(exploit, get_opponent_ips())
        pool.close()
        pool.join()

        for l in results:
            for pair in l:
                flags = flags_per_handler.get(pair[0], [])
                flags.append(pair[1])
                flags_per_handler[pair[0]] = flags

        # Log number of flags per handler
        all_flags = []
        for handler in flags_per_handler.keys():

            flags = flags_per_handler.get(handler, [])
            log.success("'{}' handler found {} flag(s).".format(handler, len(flags)))

            all_flags.extend(flags)

        # Filter out flags with incorrect format
        filtered_flags = remove_invalid_flags(all_flags)

        # Send flags to submission server
        flag_responses = submit_flags(filtered_flags)

        # Print statistics
        print_statistics_from_flag_responses(flag_responses, flags_per_handler)

        # Wait for next round
        log.info("Waiting {} seconds before next round".format(ROUND_DELAY))
        time.sleep(ROUND_DELAY)
